//	NOTE - NORM_ANGLE
// 	takes an angle as input and ensures that it falls
//	within the range of 0 to 2π2π radians (or 0 to 360 degrees in degrees mode).
double	ft_norm_angle(double angle)
{
	angle = remainder(angle, M_1_PI);
	if (angle < 0)
		angle = M_PI + angle;
	return (angle);
}

//	NOTE - IS_COORDINATE_AT_WALLS
//	this function checks whether a given coordinate (x, y) is at a wall position on a map.
int	ft_is_coord_at_wall(t_cube *data, float x, float y)
{
	if (x < 0 || x > data->size.win_width || y < 0 || y > data->size.win_height)
		return (true);
	int map_grid_index_x = floor(x / data->size.width);
	int map_grid_index_y = floor(y / data->size.height);
	printf("width: {%d}, x: {%f}, height: {%d}, y: {%f}\n", data->size.width, x, data->size.height, y);
	return (data->info->map[map_grid_index_y][map_grid_index_x] != 0);
}

//	NOTE - DISTANCE_BETWEEN_TWO_POINTS
//	this function calculates the Euclidean distance between two points (x1, y1) and (x2, y2)
float	ft_distance_between_points(float x1, float y1, float x2, float y2)
{
	return (sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1))));
}

void	ft_cast_ray(t_cube *data, double ray_angle, int strip_id)
{
	int	is_ray_facing_down;
	int	is_ray_facing_up;
	int	is_ray_facing_right;
	int	is_ray_facing_left;

	ray_angle = ft_norm_angle(ray_angle);
	is_ray_facing_down = ray_angle > 0 && ray_angle < M_PI;
	// checks whether the normalized `ray_angle` falls within the range (0, π),
	/// which corresponds to the lower half of the unit circle
	is_ray_facing_up = !is_ray_facing_down;
	// this line sets `is_ray_facing_up` to true if is_ray_facing_down is false, and vice versa.
	is_ray_facing_right = ray_angle < 0.5 * M_PI || ray_angle > 1.5 * M_PI;
	// checks whether the normalized `ray_angle` falls within the range (0, π/2] or (3π/2, 2π),
	/// which corresponds to the right-hand side of the unit circle, indicating that the ray is facing to the right.
	is_ray_facing_left = !is_ray_facing_right;
	//  this line sets `is_ray_facing_left` to true if is_ray_facing_right is false, and vice versa.

	float	x_intercept, y_intercept;
	float	x_step, y_step;
	/*********************************************************************/
	/*								HORIZANTAL							 */
	/*********************************************************************/
	int		found_horz_wall_hit = false;
	float	horz_wall_hit_x = 0;
	float	horz_wall_hit_y = 0;
	int		horz_wall_content = 0;

	// NOTE - Find the y-coordinate of the closest horizontal grid intersection
	y_intercept = floor(data->player.y / (float)data->size.height) * (float)data->size.height;
	y_intercept += is_ray_facing_down ? data->size.height : 0;

	// NOTE - Find the x-coordinate of the closest horizontal grid intersection
	x_intercept = data->player.x + (y_intercept - data->player.y) / tan(ray_angle);

	// NOTE - Calculate the increment x_step and y_step
	y_step = data->size.height;
	y_step *= is_ray_facing_up ? -1 : 1;

	x_step = data->size.height / tan(ray_angle);
	x_step *= (is_ray_facing_left && x_step > 0) ? -1 : 1;
	x_step *= (is_ray_facing_right && x_step < 0) ? -1 : 1;

	float	next_horz_touch_x = x_intercept;
	float	next_horz_touch_y = y_intercept;
	while (next_horz_touch_x >= 0 && next_horz_touch_y <= data->size.win_width && next_horz_touch_y >= 0
		&&	next_horz_touch_x <= data->size.win_height)
	{
		float	x_to_check = next_horz_touch_x;
		float	y_to_check = next_horz_touch_y + (is_ray_facing_up ? -1 : 0);
		if (ft_is_coord_at_wall(data, x_to_check, y_to_check))
		{
			horz_wall_hit_x = next_horz_touch_x;
			horz_wall_hit_y = next_horz_touch_y;
			horz_wall_content = data->info->map[(int)floor(y_to_check / data->size.height)][(int)floor(x_to_check / data->size.width)];
			found_horz_wall_hit = true;
			break ;
		}
		else
		{
			next_horz_touch_x += x_step;
			next_horz_touch_y += y_step;
		}
	}
	/*********************************************************************/
	/*								VERTICAL							*/
	/*********************************************************************/
	int		found_vert_wall_hit = false;
	float	vert_wall_hit_x = 0;
	float	vert_wall_hit_y = 0;
	int		vert_wall_content = 0;

	// NOTE - Find the x-coordinate of the closest horizontal grid intersection
	x_intercept = floor(data->player.x / (float)data->size.width) * (float)data->size.width;
	x_intercept += is_ray_facing_right ? data->size.width : 0;

	// NOTE - Find the y-coordinate of the closest horizontal grid intersection
	x_intercept = data->player.y + (x_intercept - data->player.x) * tan(ray_angle);

	// NOTE - Calculate the increment x_step and y_step
	x_step = data->size.width;
	x_step *= is_ray_facing_left ? -1 : 1;

	y_step = data->size.width * tan(ray_angle);
	y_step *= (is_ray_facing_up && y_step > 0) ? -1 : 1;
	y_step *= (is_ray_facing_down && y_step < 0) ? -1 : 1;

	float	next_vert_touch_x = x_intercept;
	float	next_vert_touch_y = y_intercept;
	while (next_vert_touch_x >= 0 && next_vert_touch_y <= data->size.win_width && next_vert_touch_y >= 0
		&&	next_vert_touch_x <= data->size.win_height)
	{
		float	y_to_check = next_vert_touch_x;
		float	x_to_check = next_vert_touch_y + (is_ray_facing_left ? -1 : 0);
		if (ft_is_coord_at_wall(data, x_to_check, y_to_check))
		{
			vert_wall_hit_x = next_vert_touch_x;
			vert_wall_hit_y = next_vert_touch_y;
			vert_wall_content = 
				data->info->map[(int)floor(y_to_check / data->size.height)][(int)floor(x_to_check / data->size.width)];
			found_vert_wall_hit = true;
			break ;
		}
		else
		{
			next_vert_touch_x += x_step;
			next_vert_touch_y += y_step;
		}
	}
	// Calculate both horz and vert hit distance
	float	horz_hit_distance = found_horz_wall_hit
		? ft_distance_between_points
			(data->player.x, data->player.y, horz_wall_hit_x, horz_wall_hit_y) : INT_MAX;
	float	vert_hit_distance = found_vert_wall_hit
		? ft_distance_between_points
			(data->player.x, data->player.y, horz_wall_hit_x, horz_wall_hit_y) : INT_MAX;
	if (vert_hit_distance < horz_hit_distance)
	{
		data->ray[strip_id].distance = vert_hit_distance;
		data->ray[strip_id].wall_hit_x = vert_wall_hit_x;
		data->ray[strip_id].wall_hit_y = vert_wall_hit_y;
		data->ray[strip_id].wall_hit_content = vert_wall_content;
		data->ray[strip_id].was_hit_vert = true;
	}
	else
	{
		data->ray[strip_id].distance = horz_hit_distance;
		data->ray[strip_id].wall_hit_x = horz_wall_hit_x;
		data->ray[strip_id].wall_hit_y = horz_wall_hit_y;
		data->ray[strip_id].wall_hit_content = horz_wall_content;
		data->ray[strip_id].was_hit_vert = false;
	}
	data->ray[strip_id].ray_angle = ray_angle;
	data->ray[strip_id].is_ray_facing_down = is_ray_facing_down;
	data->ray[strip_id].is_ray_facing_up = is_ray_facing_up;
	data->ray[strip_id].is_ray_facing_left = is_ray_facing_left;
	data->ray[strip_id].is_ray_facing_right = is_ray_facing_right;
}

void	ft_cast_all_rays(t_cube *data)
{
	int		strip_id;
	double	ray_angle;

	strip_id = 0;
	ray_angle = data->player.rotation_angle - (data->player.fov_angle / 2);
	while (strip_id < data->player.num_of_rays)
	{
		ft_cast_ray(data, ray_angle, strip_id);
		ray_angle += data->player.fov_angle / data->player.num_of_rays;
		strip_id++;
	}
}

void	ft_render_rays(t_cube *data, int color)
{
	t_line	l;
	int		i;

	(void)color;
	i = 0;
	l.x_begin = data->player.x + (PLAYER_PX / 2);
	l.y_begin = data->player.y;
	while (i < data->player.num_of_rays)
	{
		l.x_end = data->ray[i].wall_hit_x;
		l.y_end = data->ray[i].wall_hit_y;
		ft_draw_line(data, l, color);
	}
}
